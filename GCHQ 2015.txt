 
In[18]:= ClearAll[unknown,cellGraphics,specs,specsN,gridSpecs,clueRows,clueCols,constraint,constraints,possibles];
Utilities and constants
Some constants for use in display, etc.
In[18]:= unknown ="-";
cellGraphics = {
1->Graphics[{Black,Rectangle[]},ImageSize->20],
0->Graphics[{White,Rectangle[]},ImageSize->20],
unknown->Graphics[{GrayLevel[.95],Rectangle[]},ImageSize->20]};
gridSpecs = Sequence[Frame->None,Alignment->Center,ItemSize->{1.25,1.25},Spacings->{0.2,0.2}];
A function to display results
In[4]:= showTable[t_]:=Grid[Join[
Join[ConstantArray["",{9,9}],(Style[#,Bold]&/@PadLeft[#,9,""]&/@clueCols)],
(Thread[f[(Style[#,Bold]&/@PadLeft[#,9,""]&/@clueRows),(t/.cellGraphics)]]/.f->Join)
], gridSpecs];
In[5]:= (*showTable[t_]:=Grid[t/.cellGraphics, gridSpecs];*)
The problem
In[6]:= dim=25;
The "clues" along the sides of the puzzle:
In[7]:= clueRows={{7,3,1,1,7},{1,1,2,2,1,1},{1,3,1,3,1,1,3,1},{1,3,1,1,6,1,3,1},{1,3,1,5,2,1,3,1},{1,1,2,1,1},{7,1,1,1,1,1,7},{3,3},{1,2,3,1,1,3,1,1,2},{1,1,3,2,1,1},{4,1,4,2,1,2},{1,1,1,1,1,4,1,3},{2,1,1,1,2,5},{3,2,2,6,3,1},{1,9,1,1,2,1},{2,1,2,2,3,1},{3,1,1,1,1,5,1},{1,2,2,5},{7,1,2,1,1,1,3},{1,1,2,1,2,2,1},{1,3,1,4,5,1},{1,3,1,3,10,2},{1,3,1,1,6,6},{1,1,2,1,1,2},{7,2,1,2,5}};

clueCols={{7,2,1,1,7},{1,1,2,2,1,1},{1,3,1,3,1,3,1,3,1},{1,3,1,1,5,1,3,1},{1,3,1,1,4,1,3,1},{1,1,1,2,1,1},{7,1,1,1,1,1,7},{1,1,3},{2,1,2,1,8,2,1},{2,2,1,2,1,1,1,2},{1,7,3,2,1},{1,2,3,1,1,1,1,1},{4,1,1,2,6},{3,3,1,1,1,3,1},{1,2,5,2,2},{2,2,1,1,1,1,1,2,1},{1,3,3,2,1,8,1},{6,2,1},{7,1,4,1,1,3},{1,1,1,1,4},{1,3,1,3,7,1},{1,3,1,1,1,2,1,1,4},{1,3,1,4,3,3},{1,1,2,2,2,6,1},{7,1,3,2,1,1}};
Constraints (thusfar) in the puzzle):
In[9]:= constraints = ConstantArray[unknown, {dim, dim}];
(constraints[[Sequence@@#]]=1)&/@{
{4,4},{4,5},{4,13},{4,14},{4,22},
{9,7},{9,8},{9,11},{9,15},{9,16},{9,19},
{17, 7}, {17, 12}, {17, 17},{17, 21},
{22, 4},{22, 5},{22, 10},{22, 11},{22, 16},{22, 21},{22, 22}
};
showTable[constraints]
Out[11]= 											1													2						1			
											3	1	1					2		1				2						3			
											1	3	3		7		2	2		2		3		1	1					1		1	
										1	3	1	1	1	1		1	1		3		3		1	3		7		1	1	1	1	7
									7	1	1	1	1	1	1		2	2	1	1	4	1	1	1	3		1	1	3	1	3	2	1
									2	2	3	5	4	1	1		1	1	7	1	1	1	2	1	2		4	1	1	2	1	2	3
									1	2	1	1	1	2	1	1	8	1	3	1	1	1	5	1	1	6	1	1	3	1	4	2	2
									1	1	3	3	3	1	1	1	2	1	2	1	2	3	2	2	8	2	1	1	7	1	3	6	1
									7	1	1	1	1	1	7	3	1	2	1	1	6	1	2	1	1	1	3	4	1	4	3	1	1
				7	3	1	1	7																									
			1	1	2	2	1	1																									
	1	3	1	3	1	1	3	1																									
	1	3	1	1	6	1	3	1																									
	1	3	1	5	2	1	3	1																									
				1	1	2	1	1																									
		7	1	1	1	1	1	7																									
							3	3																									
1	2	3	1	1	3	1	1	2																									
			1	1	3	2	1	1																									
			4	1	4	2	1	2																									
	1	1	1	1	1	4	1	3																									
			2	1	1	1	2	5																									
			3	2	2	6	3	1																									
			1	9	1	1	2	1																									
			2	1	2	2	3	1																									
		3	1	1	1	1	5	1																									
					1	2	2	5																									
		7	1	2	1	1	1	3																									
		1	1	2	1	2	2	1																									
			1	3	1	4	5	1																									
			1	3	1	3	10	2																									
			1	3	1	1	6	6																									
			1	1	2	1	1	2																									
				7	2	1	2	5																									


The solution
The approach is to progressively refine the constraints until they are free of unknowns.
specs: the clue, expressed as a list of all possible combinations of the runs of 0s and 1s
possibles: All the possible strips matching a given spec.
constraint: The possibles for a strip expressed as a single list of known and unknown values.
Definitions
In[12]:= specsN[clue_,n_]:=
Switch[n,1,#,-1,Join[{0},#,{0}],0,{Append[#,0],Prepend[#,0]}]&/@ 
(Union@@(Permutations/@(IntegerPartitions[dim-Plus@@clue, {Length[clue]+n}])));specs[clue_]:= Riffle[#,clue]&/@Union[specsN[clue,-1],Union@@specsN[clue,0], specsN[clue,1]]
In[13]:= possibles[spec_]:=Flatten[{ConstantArray[0,#[[1]]],ConstantArray[1,#[[2]]]}&/@
 Partition[Append[spec,0],2]]
The constraint for a row or column, indicating for each cell in the row or column the value (1 or 0) if it is known; `unknown` otherwise.
Generated filtering the list of possible strips against a constraint strip.
In[14]:= constraint[_,const_]:= const/;isDone[const];
constraint[poss_,const_]:=
Module[{constrainedPoss=Cases[poss,const/.unknown->_]},
Switch[#,Length[constrainedPoss],1,0,0,_,unknown]&/@(Thread[Total[#]&@constrainedPoss])]
In[16]:= isDone[strip_] := FreeQ[strip,unknown];
Solve it
(Has a possibly unnecessary refinement of constraints using possColls if the preceeding possRow step has completed the puzzle; not worth checking.)
In[21]:= With[{possRows =( possibles[#]&/@specs[#])&/@clueRows,possCols =( possibles[#]&/@specs[#])&/@clueCols},
While[
Not@isDone@Flatten@constraints,
constraints=MapThread[constraint, {possRows,constraints}];
constraints=MapThread[constraint, {possCols,constraints}];
]]
showTable[constraints]
Out[22]= 											1													2						1			
											3	1	1					2		1				2						3			
											1	3	3		7		2	2		2		3		1	1					1		1	
										1	3	1	1	1	1		1	1		3		3		1	3		7		1	1	1	1	7
									7	1	1	1	1	1	1		2	2	1	1	4	1	1	1	3		1	1	3	1	3	2	1
									2	2	3	5	4	1	1		1	1	7	1	1	1	2	1	2		4	1	1	2	1	2	3
									1	2	1	1	1	2	1	1	8	1	3	1	1	1	5	1	1	6	1	1	3	1	4	2	2
									1	1	3	3	3	1	1	1	2	1	2	1	2	3	2	2	8	2	1	1	7	1	3	6	1
									7	1	1	1	1	1	7	3	1	2	1	1	6	1	2	1	1	1	3	4	1	4	3	1	1
				7	3	1	1	7																									
			1	1	2	2	1	1																									
	1	3	1	3	1	1	3	1																									
	1	3	1	1	6	1	3	1																									
	1	3	1	5	2	1	3	1																									
				1	1	2	1	1																									
		7	1	1	1	1	1	7																									
							3	3																									
1	2	3	1	1	3	1	1	2																									
			1	1	3	2	1	1																									
			4	1	4	2	1	2																									
	1	1	1	1	1	4	1	3																									
			2	1	1	1	2	5																									
			3	2	2	6	3	1																									
			1	9	1	1	2	1																									
			2	1	2	2	3	1																									
		3	1	1	1	1	5	1																									
					1	2	2	5																									
		7	1	2	1	1	1	3																									
		1	1	2	1	2	2	1																									
			1	3	1	4	5	1																									
			1	3	1	3	10	2																									
			1	3	1	1	6	6																									
			1	1	2	1	1	2																									
				7	2	1	2	5																									


In[23]:= BarcodeRecognize[(1-constraints)//Image]
Out[23]= www.gchq.gov.uk/puzz
Notes
Could be sped up a bit by capturing restriction of rowCells and colCells with someting like below (which has a bug somewhere) but at the expens of some complexity (and maybe all the table rearranging slows things down too much anyway):
In[17]:= (*constraintStrip[_,constraint_]:={{constraint},constraint}/;isDone[constraint];
constraintStrip[cells_,constraint_]:=
Module[{constrainedCells=Cases[cells,constraint/.unknown_]},
{constrainedCells,Switch[#,Length[constrainedCells],1,0,0,_,unknown]&/@(Thread[Total[#]&@constrainedCells])}]*)
(*With[{rowCells  =( genCells[#]&/@genSpecs[#])&/@clueRows,colCells  =( genCells[#]&/@genSpecs[#])&/@clueCols},
While[
Not@isDone@Flatten@constraintTable,
{colCells,constraintTable}=MapThread[constraintStrip, {colCells,constraintTable}];
{rowCells,constraintTable}=MapThread[constraintStrip, {rowCells,constraintTable}];
]]
showTable[constraintTable]*)